---
title: "ProyectoTD2025"
author: Jorge Ballesteros García, Emma Almenar García, Miguel Angel Aloy Poveda, Ainhoa
  Larios Bea, Samuel Lozada Borrás, Iker Martínez Bravo
date: "2025-04-07"
output:
  html_document:
    echo: true
    number_sections: false
    theme: lumen
    toc: true
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: false
  word_document:
    toc: true
    toc_depth: '3'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



# Introducción.

En este proyecto se realiza un análisis exploratorio de datos basado en tickets 
de compra del supermercado Mercadona, con el objetivo de identificar patrones de 
consumo, tendencias en los productos adquiridos y comportamientos de los clientes. 
Este trabajo se estructura en varias etapas que incluyen la carga y limpieza de 
datos, análisis descriptivo, visualización de resultados y respuesta a preguntas 
clave planteadas durante el desarrollo del proyecto.

Los tickets de compra del supermercado Mercadona han sido recogidos por los 
diferentes estudiantes de la asignatura de Tratamiento de los Datos de la carrera
Ciencia de Datos en la Universidad de Valencia.

## Carga de librerías y procesamiento inicial

Para llevar a cabo el análisis, se utilizaron principalemente las librerías de R 
pdftools, dplyr y stringr. Estas herramientas facilitan la lectura y conversión 
de los tickets desde formato PDF a texto procesable. El programa desarrollado 
incluye funciones específicas para:

- Identificar si los documentos corresponden a tickets del supermercado Mercadona.
- Extraer información clave del encabezado (nombre del supermercado, dirección, fecha, hora, etc.).
- Procesar productos listados en los tickets, incluyendo aquellos vendidos a peso.
- Capturar detalles adicionales como descuentos, IVA, método de pago o uso del parking.

Es necesario hacer esta carga antes de empezar con el programa, por tanto, 
cargamos las diferentes librerías.

```{r}
# Nos aseguramos de que el paquete "pacman" está instalado
if (!require('pacman')) install.packages('pacman')

# Cargamos las librerias
pacman::p_load(pdftools, tidyverse, readxl, lubridate, visdat, knitr, rticles, tinytex, kableExtra, patchwork, cowplot, wordcloud)

```

## Características generales del conjunto de los datos.

Los datos procesados corresponden a 355 tickets (no todos ellos válidos) obtenidos 
a partir de archivos PDF. Cada ticket contiene información organizada en las 
siguientes variables principales:

- Encabezado: Información del supermercado (nombre, dirección, localidad), fecha y hora de la compra.
- Productos: Detalles sobre cada producto adquirido (cantidad, descripción, precio unitario e importe total).
- Totales: Subtotal, IVA, descuentos aplicados e importe total del ticket.
- Extras: Datos sobre donaciones realizadas, uso del parking (hora de entrada y salida) y método de pago.

## Análisis de valores faltantes.

Se utilizó la librería VIM para analizar los valores faltantes (NA) en el dataset. 
Los principales hallazgos incluyen:

- Algunos tickets no contenían información completa sobre las categorías de productos.
- En ciertos casos, el precio unitario o la cantidad estaban ausentes debido a errores en el registro.

Para abordar estos problemas, se aplicaron reglas específicas:

- Los registros con precios unitarios faltantes fueron eliminados si no era posible imputar un valor razonable.
- Los valores NA en las categorías fueron imputados utilizando patrones observados en otros registros similares.

## Preguntas planteadas.

El análisis busca responder a preguntas clave relacionadas con los patrones de compra como las siguientes:
- ¿Cuáles son los 5 productos más comprados? ¿Y cuántas veces ha sido comprado el qué más?
- ¿Qué días presentan mayor volumen de ventas? ¿Se observan picos específicos durante la semana?
- ¿Qué producto aparece más veces en tickets de más de 100 €?
- ¿Cuál es la mayor cantidad pagada de impuestos y en qué localización se ha producido?
- ¿Qué día de la semana es el que menos compras registra?

# Métodos y materiales.


# Creación de la función para la lectura de tickets.

El primer paso del proyecto consiste en la automatización de un código para la 
lectura de los diferentes tickets de compra del Mercadona. Para ello creamos una 
función que procese un ticket individual, y como todos los tickets comparten el
mismo formato, podremos utilizarla para la lectura de todos. 

Lo primero que hacemos en la función para la lectura de los tickets es una subfunción 
para la leer los archivos PDF y convertir la información obtenida en líneas de
texto procesadas.

```{r}

leer_pdf <- function(archivo) {
  texto <- pdf_text(archivo) #Lee la información del PDF
  lineas <- unlist(strsplit(paste(texto, collapse = "\n"), "\n")) #Transforma la información en líneas de texto procesadas
  trimws(lineas)
}
```

Después creamos otra subfunción que busca la palabra "MERCADONA" en mayúsculas de las 
líneas de texto procesadas para seleccionar solo los tickets pertenecientes a este 
supermecado.

```{r}

es_mercadona <- function(lineas) {
  if(length(lineas) == 0) return(FALSE) #Si no lee información del ticket
  any(grepl("^MERCADONA\\b", lineas))  # ^ indica inicio de línea, \b para palabra completa
}

```

El siguiente paso es crear otra subfunción para procesar las líneas y extaer la 
información de los tickets, necesaria para analizar y posteriormente contestar a 
las cuestiones planteadas. En esta subfunción indicaremos si el ticket es o no del 
Mercadona, en el caso del ser del Mercadona incializaremos uns lista para almacenar 
los datos de los tickets (como supermercado, direccion, cp, localidad,...)

```{r}

procesar_lineas <- function(lineas) {
  if(!es_mercadona(lineas)) {
    message("El texto no corresponde a un ticket de Mercadona")
    return(NULL) #Si el ticket no es de Mercadona
  }
  
#Inicializamos una lista para almacenar datos. Esta lista incluye los datos de tanto el encabezado, como los productos
  datos<-list(
    supermercado = NA,
    direccion = NA,
    cp = NA,
    localidad = NA,
    telefono = NA,
    fecha = NA,
    hora = NA,
    op = NA,
    factura_simplificada = NA,
    
#Creamos dentro de la lista para almacenar los datos, un dataframe que va a contener los productos del ticket.
    
    productos = data.frame(
      cantidad = numeric(),
      descripcion = character(),
      importe = numeric(),
      stringsAsFactors = FALSE
    ),
    parking = FALSE,
    hora_entrada_parking = NA,
    hora_salida_parking = NA,
    donacion = NA,
    metodo_pago = NA,
    tarjeta = NA,
    subtotal = NA,
    descuento = NA,
    IVA = NA,
    importe_total = NA
  )
  
  
  #Procesar encabezado:
  
  #Extraer el supermercado
  datos$supermercado<- trimws(lineas[1])
  datos$supermercado
  
  #Extraer la dirección
  datos$direccion<- trimws(lineas[2])
  datos$direccion
  
  #Extraer CP y localidad (ejemplo: "04630 GARRUCHA")
  
  localidad_cp<- trimws(lineas[3]) #Usamos trimws para asegurarnos de eliminar los espacios en blanco anteriores al CP.
  localidad_cp #CP y localidad juntos
  
  datos$cp<- gsub("([0-9]+).*", "\\1", localidad_cp) #Extraemos solo el CP.
  datos$cp
  
  datos$localidad<- gsub("[0-9]+ (.*)", "\\1", localidad_cp) #Extraemos solo la localidad
  
  datos$localidad
  
  #Extraer teléfono
  telefono_linea<-lineas[4]
  datos$telefono<- gsub(".*TELÉFONO: (.*)", "\\1", telefono_linea)
  datos$telefono
  
  #Extraer fecha, hora y OP
  fecha_hora_linea<- trimws(lineas[5]) # 25/11/2023 09:09 OP: 78800
  partes<-unlist(strsplit(fecha_hora_linea, " ")) #Separamos los elementos por espacios
  datos$fecha<-partes[1]
  datos$fecha
  datos$hora<- partes[2]
  datos$hora
  datos$op<- paste(partes[3],partes[4]) #Unimos los dos elementos en una cadena ("OP: 78800")
  datos$op
  
  #Extraer de la factura simplificada el código del ticket y el código del supermercado
  linea_factura_simplificada <- lineas[6]
  datos$factura_simplificada <- trimws(gsub("FACTURA SIMPLIFICADA:", "", linea_factura_simplificada))  
  componentes_factura_simplificada <- unlist(strsplit(linea_factura_simplificada, "-"))
  datos$num_tienda <- componentes_factura_simplificada[1] 
  datos$num_caja<- componentes_factura_simplificada[2] 
  datos$factura_numero <- componentes_factura_simplificada[3]
  
    # Función para buscar la línea de inicio de los productos
  buscar_inicio_productos <- function(lineas) {
    return(grep("^\\s*Descripción\\s+P\\. Unit\\s+Importe", lineas))
  }
  
  # Función para buscar la línea de fin de los productos
  buscar_fin_productos <- function(lineas) {
    return(grep("^\\s*TOTAL \\(€\\)", lineas)[1] - 1)
  }
  
  # Función para extraer productos normales (cantidad, descripción, [precio_unitario], importe)
    extraer_producto <- function(linea) {
    # Caso con precio_unitario y total
    match_con_unitario <- str_match(linea, "^\\s*(\\d+(?:[.,]\\d+)?)\\s+(.*?)\\s+(\\d+[.,]\\d+)\\s+(\\d+[.,]\\d+)$")
    if (!is.na(match_con_unitario[1,1])) {
      cantidad <- as.numeric(gsub(",", ".", match_con_unitario[1,2]))
      descripcion <- trimws(match_con_unitario[1,3])
      precio_unitario <- as.numeric(gsub(",", ".", match_con_unitario[1,4]))
      importe <- as.numeric(gsub(",", ".", match_con_unitario[1,5]))
      return(data.frame(cantidad = cantidad, descripcion = descripcion, precio_unitario = precio_unitario, importe = importe, stringsAsFactors = FALSE))
    }

    # Caso sin precio_unitario
    match_simple <- str_match(linea, "^\\s*(\\d+(?:[.,]\\d+)?)\\s+(.*?)\\s+(\\d+[.,]\\d+)$")
    if (!is.na(match_simple[1,1])) {
      cantidad <- as.numeric(gsub(",", ".", match_simple[1,2]))
      descripcion <- trimws(match_simple[1,3])
      importe <- as.numeric(gsub(",", ".", match_simple[1,4]))
      return(data.frame(cantidad = cantidad, descripcion = descripcion, precio_unitario = NA, importe = importe, stringsAsFactors = FALSE))
    }

    return(NULL)
  }
  
  # Función extraer_producto_peso
  extraer_producto_peso <- function(linea_actual, linea_siguiente) {
    match_peso <- str_match(linea_siguiente, "([0-9.,]+)\\s*kg\\s+([0-9.,]+)\\s*€/kg\\s+([0-9.,]+)")
    if (!is.na(match_peso[1,1])) {
      cantidad <- 1
      descripcion <- trimws(linea_actual)
      peso <- gsub(",", ".", match_peso[1,2])
      precio_kg <- gsub(",", ".", match_peso[1,3])
      importe <- gsub(",", ".", match_peso[1,4])
      descripcion_completa <- paste0(descripcion, " (", peso, " kg a ", precio_kg, " €/kg)")
      return(data.frame(cantidad = cantidad, descripcion = descripcion_completa, precio_unitario = as.numeric(precio_kg), importe = as.numeric(importe), stringsAsFactors = FALSE))
   }
    return(NULL)
  }
  
  # Función para procesar productos y agregar datos
  procesar_productos <- function(lineas) {
    linea_inicio_productos <- buscar_inicio_productos(lineas)
    if (length(linea_inicio_productos) > 0) {
     inicio <- linea_inicio_productos + 1
      fin <- buscar_fin_productos(lineas)

      if (!is.na(fin) && inicio < fin) {
        productos_brutos <- lineas[inicio:fin]
        i <- 1
        productos <- data.frame(cantidad = numeric(), descripcion = character(), importe = numeric(), stringsAsFactors = FALSE)

        while (i <= length(productos_brutos)) {
          linea <- productos_brutos[i]
        
         # Intentamos extraer el producto normal
          producto <- extraer_producto(linea)
          if (!is.null(producto)) {
            productos <- rbind(productos, producto)
            i <- i + 1
          } else {
            # Intentamos extraer un producto a peso si no es normal
            if (i < length(productos_brutos)) {
              linea_actual <- productos_brutos[i]
              linea_siguiente <- productos_brutos[i + 1]

             producto_peso <- extraer_producto_peso(linea_actual, linea_siguiente)
              if (!is.null(producto_peso)) {
                productos <- rbind(productos, producto_peso)
                i <- i + 2  # saltamos 2 líneas
              } else {
              i <- i + 1
              }
            } else {
              i <- i + 1
            }
          }
        }
        return(productos)
      }
    }
    return(NULL)
  }
  
  # Llamamos a procesar_productos para extraer los productos del ticket
  productos_extraidos <- procesar_productos(lineas)
  if (!is.null(productos_extraidos)) {
    datos$productos <- productos_extraidos  # Asignamos los productos al dataframe dentro de datos
  }  

  #Extraer IVA y subtotal
  linea_total_iva <- grep("^TOTAL\\s+[0-9.,]+\\s+[0-9.,]+$", lineas, value = TRUE)
  if (length(linea_total_iva) > 0) {
    partes <- unlist(strsplit(gsub(",", ".", linea_total_iva[1]), "\\s+"))
    datos$subtotal <- as.numeric(partes[2])
    datos$IVA <- as.numeric(partes[3])
  } else {
    datos$subtotal <- NA
    datos$IVA <- NA
  }
  
  #Extraer importe total
  linea_total <- grep("TOTAL \\(€\\)", lineas, value = TRUE)[1]
  if (!is.na(linea_total)) {
    datos$importe_total <- as.numeric(gsub(",", ".", gsub(".*TOTAL \\(€\\)\\s*([0-9.,]+).*", "\\1", linea_total)))
  } else {
    datos$importe_total <- NA
  }
  
  #Extraer descuento
  linea_descuento <- grep("DESCUENTO|DTO", lineas, value = TRUE, ignore.case = TRUE)
  if (length(linea_descuento) > 0) {
    datos$descuento <- as.numeric(gsub(",", ".", gsub(".*([0-9]+,[0-9]{2}).*", "\\1", linea_descuento[1])))
  } else {
    datos$descuento <- NA
  }
  
  #Extraer donación
  
  'linea_donacion <- grep("DONACIÓN", lineas, value = TRUE)
  if (length(linea_donacion) > 0) {
    datos$donacion <- as.numeric(gsub(",", ".", gsub(".*DONACIÓN:\\s*([0-9.,]+).*", "\\1", linea_donacion[1])))
  } else {
    datos$donacion <- NA
  }
  '
linea_donacion <- grep("DONACIÓN", lineas, value = TRUE)
if (length(linea_donacion) > 0) {
  # Busca el primer número con coma o punto como separador decimal
  nro <- str_extract(linea_donacion[1], "\\d+[\\.,]\\d+")
  if (!is.na(nro)) nro <- gsub(",", ".", nro)
  datos$donacion <- as.numeric(nro)
} else {
  datos$donacion <- NA
}
  #Obtenemos que solamente hay dos tickets con donación. Cada uno con una donación de 1€.
  #Estos son: 20231125 Mercadona 37,76 €.pdf y 
  
  #Extraer parking (hora entrada y salida si hay)
  linea_parking <- grep("PARKING", lineas)
if (length(linea_parking) > 0) {
  datos$parking <- TRUE
  # Buscar la línea siguiente que contenga ENTRADA y SALIDA
  for (i in seq_along(linea_parking)) {
    idx <- linea_parking[i] + 1
    if (idx <= length(lineas)) {
      linea_horas <- lineas[idx]
      if (grepl("ENTRADA", linea_horas) && grepl("SALIDA", linea_horas)) {
        datos$hora_entrada_parking <- gsub(".*ENTRADA\\s+([0-9:]{4,5}).*", "\\1", linea_horas)
        datos$hora_salida_parking <- gsub(".*SALIDA\\s+([0-9:]{4,5}).*", "\\1", linea_horas)
        break}
    }
  }
} else {
  datos$parking <- FALSE
}
  
  #Extraer método de pago
  linea_pago <- grep("TARJETA|MASTERCARD|EFECTIVO|DEBIT", lineas, value = TRUE, ignore.case = TRUE)
  if (length(linea_pago) > 0) {
    metodo <- grep("MASTERCARD|VISA|EFECTIVO|DEBIT|TARJETA", linea_pago, value = TRUE, ignore.case = TRUE)
    if (length(metodo) > 0) {
      datos$metodo_pago <- toupper(gsub(".*(MASTERCARD|VISA|DEBIT|EFECTIVO|TARJETA).*", "\\1", metodo[1]))
    } else {
      datos$metodo_pago <- NA
    }
  }
  
  #Extraer tarjeta
  linea_tarjeta <- grep("TARJ. BANCARIA", lineas, value = TRUE)
  if (length(linea_tarjeta) > 0) {
    datos$tarjeta <- gsub(".*\\*+\\s*([0-9]{4}).*", "\\1", linea_tarjeta[1])
  } else {
    datos$tarjeta <- NA
  }
    
  
  return(datos)
  
}


```


A continuación, definimos la función procesar_tickets() para automatizar la lectura 
y extracción de datos de múltiples tickets PDF ubicados en la carpeta data. 
Para cada archivo, se leen sus líneas de texto y se verifica si pertenece a 
Mercadona con es_mercadona(). Si es válido, se procesan sus datos con 
procesar_lineas() y se almacenan en una lista junto con el nombre del archivo. 
La función maneja errores durante la lectura y filtra tickets no válidos, 
devolviéndonos solo los correctamente procesados.

```{r}
#Función para procesar múltiples tickets PDF.

procesar_tickets <- function(directorio = "data") {
  
  # Listar todos los archivos PDF en el directorio
  archivos <- list.files(path = directorio, pattern = "\\.pdf$", full.names = TRUE)
  
  # Inicializar lista para almacenar resultados
  lista_tickets <- list()
  
  c<- 1
  # Procesar cada archivo
  for (i in seq_along(archivos)) {
    archivo <- archivos[i]
    cat("Procesando:", basename(archivo), "...\n")
  
  tryCatch({
      # Leer y procesar el PDF
      lineas <- leer_pdf(archivo)
      if (es_mercadona(lineas)){
        
        datos_ticket <- procesar_lineas(lineas)
      
        # Agregar nombre del archivo a los datos
        datos_ticket$archivo <- basename(archivo)
        
        # Almacenar en la lista
        lista_tickets[[c]] <- datos_ticket
        c <- c+1
        
      }
    }, error = function(e) {
      warning("Error al procesar el archivo ", basename(archivo), ": ", e$message)
      #lista_tickets[[i]] <- NULL
    })
  }
  
  # Filtrar elementos NULL (archivos que no se pudieron procesar)
  lista_tickets <- Filter(Negate(is.null), lista_tickets)
  
  return(lista_tickets)
}

# Procesar todos los tickets en la carpeta data
todos_los_tickets <- procesar_tickets()

# Vemos los tres primeros tickets procesados correctamente (aquellos pdfs de Mercadona con formato texto)
print(todos_los_tickets[[1]])

print(todos_los_tickets[[2]])

print(todos_los_tickets[[3]])



# Ver cuántos tickets se procesaron correctamente
length(todos_los_tickets) #Se procesan correctamente 306


```

Creamos un dataframe a partir de la lista de ticket. Para ello, definimos la función tickets_a_dataframe() para transformar la lista de tickets procesados en un dataframe, donde cada fila representa un ticket y cada columna una variable relevante (como fecha, importe total, dirección, método de pago, etc.). Una vez creado el dataframe df_tickets, visualizamos su contenido y inspeccionamos los tipos de datos. 
Para facilitar su análisis, en el segundo cuadro ajustamos los formatos de fecha y hora utilizando funciones del paquete lubridate. Esto nos permite trabajar correctamente con valores temporales como la hora de compra o el tiempo de aparcamiento.

```{r}
# Vamos a convertir la lista de tickets en un dataframe (cada fila es un ticket y cada columna una variable).

tickets_a_dataframe <- function(lista_tickets) {
  df <- do.call(rbind, lapply(lista_tickets, function(ticket) {
    data.frame(
      archivo = ticket$archivo,
      supermercado = ticket$supermercado,
      direccion = ticket$direccion,
      telefono = ticket$telefono,
      cp = ticket$cp,
      localidad = ticket$localidad,
      fecha = ticket$fecha,
      hora = ticket$hora,
      op = ticket$op,
      factura_simplificada = ticket$factura_simplificada,
      num_tienda = ticket$num_tienda,
      num_caja = ticket$num_caja,
      factura_numero = ticket$factura_numero,
      importe_total = ticket$importe_total,
      subtotal = ticket$subtotal,
      IVA = ticket$IVA,
      descuento = ticket$descuento,
      donacion = ticket$donacion,
      metodo_pago = ticket$metodo_pago,
      tarjeta = ticket$tarjeta,
      parking = ticket$parking,
      hora_entrada_parking = ticket$hora_entrada_parking,
      hora_salida_parking = ticket$hora_salida_parking,
      stringsAsFactors = FALSE
    )
  }))
  return(df)
}


# Con la función convertimos la lista a dataframe
df_tickets <- tickets_a_dataframe(todos_los_tickets)
df_tickets #Mostramos el contenido del dataframe

#Utilizamos la función kable() para representar la tabla

kable(df_tickets, caption = "Tabla 1: Resumen de tickets de Mercadona procesados \\label{tab:ejemplo-tickets}" )

```

Los resultados, mostrados en la Tabla \@ref(tab:ejemplo-tickets), revelan que

```{r}

#Nos hacemos una idea del tipo de dato de cada columna.

#Y por tanto, vamos a cambiar el tipo de dato de las siguientes columnas:


table(df_tickets$hora, useNA="ifany")


df_tickets<- df_tickets %>% mutate(
  fecha = dmy(fecha), #Cambiamos la columna de fecha a tipo fecha
 #Cambiamos las horas a fromato hm
  hora = hm(hora),
      
  hora_entrada_parking =
      hm(hora_entrada_parking),

  hora_salida_parking =
      hm(hora_salida_parking)
)
#Revisar hora_entrada_parking, hora_salida_parking, descuento y donación

str(df_tickets)


```

# Resolución de las cuestiones planteadas

Una vez que los datos de los tickets han sido correctamente almacenados y etiquetados 
en nuestro data frame, iniciamos el proceso de análisis para extraer información 
significativa. Este análisis nos permite identificar tendencias de compra, patrones 
de consumo, comportamientos recurrentes de los clientes y otras curiosidades que, 
a simple vista, podrían pasar desapercibidas.

Estas preguntas no solo nos permiten interpretar el presente, sino por ejemplo 
también permiten a las empresas como Mercadona anticipar tendencias futuras, 
mejorar la experiencia del cliente, ajustar estrategias de precios y promociones, 
y, en última instancia, aumentar la eficiencia operativa y la rentabilidad del 
negocio.

Por ello, nos hemos planteado ciertas preguntas que contestaremos con la informacion 
de los tickets recopilados.

Primero resolvemos las preguntas que se plantean en el enunciado del proyecto:

## Preguntas planteadas en el enunciado 

### Pregunta 1 

¿Cuáles son los 5 productos, de los vendidos por unidades, con más ventas ? 
¿Cuántas unidades de cada uno se han vendido ?

Para la resolución de esta cuestión primero creamos una lista con todos los 
productos de los tickets del dataframe para poder trabajar sobre ella. Después 
filtraremos la lista por aquellos productos que se venden por unidades y los agruparemos 
por nombre para luego hacer un recuento de cuantas veces se ha comprado ese producto.

```{r}

#Creamos la lista con todos los productos del dataframe
todos_los_productos <- bind_rows(lapply(todos_los_tickets, function(ticket) ticket$productos))

#Filtramos los productos a aquellos que se venden por unidades
todos_productos_unidades <- todos_los_productos %>% filter(
    cantidad %% 1 == 0,  # cantidad entera
    !grepl("kg|€/kg", descripcion, ignore.case = TRUE)  # no se menciona peso
  )

#Agrupamos los productos por nombre
todos_productos_unidades <- todos_productos_unidades %>% group_by(descripcion)

#Contamos la cantidad de veces que se compran todos los productos que tienen el mismo nombre
todos_productos_unidades <- todos_productos_unidades %>% summarise(unidades_vendidas = sum(cantidad, na.rm = TRUE)) 

```

Ahora para visualizamos en forma de tabla los cinco productos que se venden por unidades 
más vendidos. Para ello, ordenamos los productos en orden descendente por la cantidad 
de veces que se ha vendido, es decir, ordenamos los productos del más vendido al 
menos vendido; y, por último, mostramos las primeras cinco filas de la tabla para 
mostrar los cinco porductos más vendidos.

```{r}
#Ordenamos los productos de manera descendente
todos_productos_unidades <- todos_productos_unidades %>% arrange(desc(unidades_vendidas)) 

#Cogemos los cinco primeros productos de la tabla
todos_productos_unidades <- todos_productos_unidades %>% slice_head(n = 5)

#Mostramos la tabla
print(todos_productos_unidades)

```
En la tabla podemos observar que el producto más vendido en los tickets analizados 
es el atun claro de oliva con 62 unidades vendidas. También podemos observar que 
mucha gente no lleva bolsa a la compra y pide una al pagar porque el tercer producto
más vendido son las bolsas de plástico con 50 unidades vendidas. 

Para observar mejor los datos anteriores, representamos la información anterior en
un gráfico de barras

```{r}

library(ggplot2)

# Creamos la gráfica
ggplot(todos_productos_unidades, aes(x = reorder(descripcion, -unidades_vendidas), 
                                     y = unidades_vendidas, 
                                     fill = descripcion)) +
  geom_bar(stat = "identity") +
  labs(title = "Top 5 productos más vendidos por unidades",
       x = "Producto",
       y = "Unidades vendidas") +
  theme_minimal() +
  theme(legend.position = "none") +  # Oculta la leyenda (porque los colores ya están en el eje x)
  scale_fill_brewer(palette = "Set2")  # Paleta de colores agradable


```

En la tabla vemos de forma clara los 5 productos más vendidos y la diferencia entre 
las cantidades vendidas de cada uno.

### Pregunta 2

Si consideramos la categoría de FRUTAS Y VERDURAS. Cuáles son los 5 productos 
más vendidos ? ¿Cuántos kilos se han vendido de cada uno de estos productos?

Como en el apartado anterior hemos creado una lista con todos los productos del 
dataframe, en esta cuestión la filtramos para encontrar aquellos productos que 
pertenecen a la categoria FRUTAS Y VERDURAS. Esto lo hacemos gracias a que si mostramos
el dataframe con todos los productos vemos que los que forman parte de la categoria 
FRUTAS Y VERDURAS su nombre comienza por un 1 y después de su nombre aparece entre 
paréntesis el precio por kilo. Tras fijarnos en esto filtramos la lista con los 
nombres de todos los productos.

Después extaremos del nombre del producto el nombre del producto y la cantidad de 
kilos vendidos, para luego agrupar los productos por nombre, contar cuantas veces aparecen 
y sumar los kilos totales comprados. 

```{r}

# Filtrar productos de frutas y verduras
frutas_verduras <- todos_los_productos %>%
  filter(str_detect(descripcion, "^1.*\\(.*kg.*\\)"))

# Extraer los kilos vendidos de la descripción
frutas_verduras <- frutas_verduras %>%
  mutate(kilos_vendidos = as.numeric(str_extract(descripcion, "(?<=\\()\\d+\\.\\d{3}")))

# Agrupar por el nombre del producto sin el "1" de delante
frutas_verduras_mas_vendidas <- frutas_verduras %>%
  mutate(producto = str_remove(str_extract(descripcion, "^[^\\(]+"), "^1 ")) %>%
  group_by(producto) %>%
  summarise(
    veces_comprado = n(),                    
    kilos_totales = sum(kilos_vendidos))  %>%
  arrange(desc(kilos_totales)) %>%
  head(5)
  summarise(kilos_totales = sum(kilos_vendidos, na.rm = TRUE),
    veces_comprado = n()) 

```

Por último, ordenamos los datos obtenidos de manera descendente por el número de veces 
que se ha comprado el producto, es decir, del que más veces se ha vendido al que menos
veces se ha vendido. Después, seleccionamos las 5 primeras filas y las mostramos para 
los 5 productos de FRUTA Y VERDURA más vendidos. 

```{r}

#Odenamos las frutas y verduras y cogemos las cinco primeras cinco filas
frutas_verduras_mas_vendidas <- frutas_verduras_mas_vendidas %>%
  arrange(desc(veces_comprado)) %>%  #Ordenamos de mayor a menor
  head(5) #Elegimos las dos primeras
>>>>>>> 77110e4a2734bc404a722533a277bb885b5c2950

# Ver los resultados
print(frutas_verduras_mas_vendidas)

```
Como hablamos de peso, aunque queremos saber los cinco productos más vendidos, nos interesa 
conocer las veces que se vende ese producto, porque el que se vende más peso no significa que 
sea el mñas comprado, ya que se podría dar el caso que compro una unidad de un producto muy pesado, 
pero que compro muchas unidades de un producto muy poco pesado, el más comprado sería el de poco peso. 

Para observar mejor los datos obtenidos en este ejercicio representaremos los datos 
en una gráfica junto con la cantidad de kilos que se han comprado.

```{r}

ggplot(frutas_verduras_mas_vendidas, aes(x = reorder(producto, -veces_comprado), 
                                         y = veces_comprado, 
                                         fill = producto)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = round(veces_comprado, 2)), vjust = -0.5, size = 4) +
  labs(title = "Top 5 frutas y verduras más vendidas (por kilos)",
       x = "Producto",
       y = "Veces comprado") +
  theme_minimal() +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_brewer(palette = "Set3")

```
En la tabla vemos que el producto de la categoria FRUTAS Y VERDURAS más comprado 
con diferencia es el plátano.

### Pregunta 3

Si consideramos la categoría de PESCADO. Cuáles son los 5 productos más vendidos?
¿Cuántos kilos se han vendido de cada uno de estos productos ?

Como en el apartado anterior hemos creado una lista con todos los productos del 
dataframe, en esta cuestión la filtramos para encontrar aquellos productos que 
pertenecen a la categoria PESCADO. Esto lo hacemos gracias a que si mostramos
el dataframe con todos los productos vemos que los que forman parte de la categoria 
PESCADO después de su nombre aparece entre paréntesis el precio por kilo y no llevan un 1 delante 
como los productos del ejercicio anterior. Tras fijarnos en esto filtramos la lista con los 
nombres de todos los productos.

Después extaremos del nombre del producto el nombre del producto y la cantidad de 
kilos vendidos, para luego agrupar los productos por nombre, contar cuantas veces aparecen 
y sumar los kilos totales comprados. 

```{r}

# Filtramos los productos que pertenecen a la categoria pescado 
pescado <- todos_los_productos %>%
  filter(str_detect(descripcion, "^((?!^1).)*\\(.*kg.*\\)"))

# Extraemos los kilos vendidos de la descripción
pescado <- pescado %>%
  mutate(kilos_vendidos = as.numeric(str_extract(descripcion, "(?<=\\()\\d+\\.\\d{3}")))

# Agrupamos por nombre del producto y sumamos los kilos vendidos
pescados_mas_vendidos <- pescado %>%
  mutate(producto = str_extract(descripcion, "^[^\\(]+")) %>%
  group_by(producto) %>% 
  summarise(kilos_totales = sum(kilos_vendidos, na.rm = TRUE),
    veces_comprado = n())   

```

Por último, ordenamos los datos obtenidos de manera descendente por el número de veces 
que se ha comprado el producto, es decir, del que más veces se ha vendido al que menos
veces se ha vendido. Después, seleccionamos las 5 primeras filas y las mostramos para 
los 5 productos de la categoria PESCADO más vendidos. 

```{r}

pescados_mas_vendidos <- pescados_mas_vendidos %>%
  arrange(desc(kilos_totales)) %>% #Ordenamos de mayor a menor
  head(5) #Cogemos las cinco primeras filas 

# Mostramos los 5 pescados más vendidos junto a los kilos totales vendidos
print(pescados_mas_vendidos)

```

Como hablamos de peso, aunque queremos saber los cinco productos más vendidos, nos interesa 
conocer las veces que se vende ese producto, porque el que se vende más peso no significa que 
sea el mñas comprado, ya que se podría dar el caso que compro una unidad de un producto muy pesado, 
pero que compro muchas unidades de un producto muy poco pesado, el más comprado sería el de poco peso. 

Para observar mejor los datos obtenidos en este ejercicio representaremos los datos 
en una gráfica junto con la cantidad de kilos que se han comprado.

```{r}

ggplot(pescados_mas_vendidos, aes(x = reorder(producto, -veces_comprado), 
                                         y = veces_comprado, 
                                         fill = producto)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = round(veces_comprado, 2)), vjust = -0.5, size = 4) +
  labs(title = "Top 5 frutas y verduras más vendidas (por kilos)",
       x = "Producto",
       y = "Veces comprado") +
  theme_minimal() +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_brewer(palette = "Set3")

```

### Pregunta 4

Muestra mediante un gráfico de líneas como ha variado el precio por kilo de las 
bananas y los plátanos en los tickets disponibles, a lo largo del tiempo.

Para este ejercicio vaolvemos a crear la lista con todos los proyectos junto a su 
fecha de compra, porque tenemos que estudiar la evolución de los precios con el tiempo.
Después filtramos los productos para seleccionar solo los plátanos y bananas. 

```{r}

library(dplyr)
library(ggplot2)

#Seleccionamos de la lista con toda la información todos los productos y su fecha de venta 
todos_los_productos <- bind_rows(lapply(todos_los_tickets, function(ticket) {
  if (nrow(ticket$productos) > 0) { 
    ticket_productos <- ticket$productos
    ticket_productos$fecha <- ticket$fecha
    return(ticket_productos)
  } else {
    return(NULL)
  }
}))

# Filtramos las bananas y los plátanos
frutas <- todos_los_productos %>% filter(str_detect(tolower(descripcion), "banana|platano")) 

```
 
Después, seleccionamos y guardamos el precio del kilo del los platanos y bananas
del nombre del producto en cada fecha. Además de comprobar que la fecha está en formato correcto. 

```{r}

#Seleccionamos el precio del kilo que se encuentra al lado del nombre del producto
frutas <- frutas %>% 
  mutate(precio_kilo = as.numeric(str_extract(descripcion, "(?<=a )\\d+\\.\\d{2}"))) 

#Comprobamos que las fechas se encuntren en el formato correcto
frutas$fecha <- as.Date(frutas$fecha, format = "%d/%m/%Y") 

# Normalizamos los nombres (banana vs platano)
frutas <- frutas %>%
  mutate(tipo = case_when(
    str_detect(tolower(descripcion), "banana") ~ "Banana",
    str_detect(tolower(descripcion), "platano") ~ "Platano"
  ))

```

Por último, como nos pide el enunciado creamos un gráfico de líneas para observar 
la evolución del precio del kilo de la banana y el platano. 

```{r}

# Creamos la gráfica con la evolución del precio por kilo
ggplot(frutas, aes(x = fecha, y = precio_kilo, color = tipo)) +
  geom_line() +
  labs(
    title = "Variación del precio por kilo: Bananas vs Plátanos",
    x = "Fecha",
    y = "Precio por kilo (€)",
    color = "Producto"
  ) +
  theme_minimal()

```

En la gráfica, observamos que el precio del plátano es bastante irregular y que tuvo 
una crecida muy grande en verano del 2024. En cambio, la banana tiene un precio muy regular 
excepto a finales de 2025 que tuvo una pequeña bajada. 


### Pregunta 5

¿ Cuál es la procedencia de los tickets ?¿ Qué ciudad/ pueblo tiene un mayor número de tickets ?

Queremos ver cual es la procedencia de los tickets, es decir, la localidad donde 
se encuentra el Mercadona donde se ha hecho la compra. Para ello, realizamos una función 
donde seleccionamos del dataframe agrupadas por nombre todas las localidades 
donde se ha realizado una compra y después hacemos un recuento de la cantidad de 
veces que aparece cada localidad. 

```{r}

tickets_por_localidad <- df_tickets %>%
  group_by(localidad) %>%
  summarise(num_tickets = n()) 

```

Ahora para ver cual es la localidad donde se han registrado un mayor número de
tickets ordenamos los valores recogidas anteriormente de mayor a menor.

```{r}

tickets_por_localidad <- tickets_por_localidad %>%
  arrange(desc(num_tickets))

```

Ahora creamos una tabla mostrando todas las localidades donde se ha realizao una 
compra junto a la cantidad de compras que se ha realizdo en esa localidad. También 
mostramos cual es la localidad de donde proceden más tickets.

```{r}

kable(tickets_por_localidad, caption = "Número de tickets por ciudad/pueblo")

localidad_top <- tickets_por_localidad %>% slice(1)  #Seleccionamos la localidad con más tickets 
cat("La ciudad/pueblo con mayor número de tickets es:", localidad_top$localidad, 
    "con", localidad_top$num_tickets, "tickets.\n")

localidad_top #mostramos la localidad con más tickets

```

Para ver los datos recogidos de manera más clara creamos un gráfico de barras que 
muestre la información. 

```{r}

library(ggplot2)

graficar_tickets_por_localidad <- function(data) {
  ggplot(data, aes(x = reorder(localidad, -num_tickets), y = num_tickets)) +
    geom_bar(stat = "identity", fill = "steelblue") +
    labs(
      title = "Número de tickets por ciudad/pueblo",
      x = "Localidad",
      y = "Número de tickets"
    ) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}

# Usar la función con tus datos:
graficar_tickets_por_localidad(tickets_por_localidad)


```

Podemos ver que la ciudad/pueblo que mas tickets tiene es Valencia con 121, y le siguen Alboraya y Alcoy. Tiene sentido, ya que Valencia es la capital y la localidad con mas habitantes de la provincia de Valencia y de la CV, y por tanto es mas probable que haya más alumnos con tickets de Valencia.

### Pregunta 6

Muestra mediante un diagrama el número de tickets recogidos cada día de las semana. ¿Si tuvieses que cerrar un día entre semana qué día lo harías ?

Queremos ver que día de la semana se han recogido menos tickes, sabemos que los domingos 
es habitual el cierre del supermercado Mercadona, aunque a veces abre estos días por 
motivos excepcionales. 

Para ver que día de la semana se hacen menos compras, del dataframe seleccionamos el día de 
la semana en que se ha hecho la compra de cada ticket. Después contamos cuantas veces 
aparece este día de la semana y lo mostramos en una tabla. 

```{r}

tickets_por_dia <- df_tickets %>%
  mutate(dia_semana = wday(fecha, label = TRUE, abbr = FALSE, week_start = 1, locale = "es_ES.UTF-8")) 

tickets_por_dia <- tickets_por_dia %>%
  count(dia_semana) #contamos los cuantas veces aparece cada dái 

#Hacemos la tabla
kable(tickets_por_dia, caption = "Número de tickets por día de la semana")

```

Creamos un gráfico de barras con los días de la semana y el número de veces que se
ha comprado en ese día, para ver con mayor claridad la información obtenida.

```{r}
ggplot(tickets_por_dia, aes(x = dia_semana, y = n, fill = dia_semana)) +
  geom_bar(stat = "identity", show.legend = FALSE) +
  labs(title = "Número de tickets por día de la semana",
       x = "Día de la semana", y = "Número de tickets") +
  theme_minimal()

```

Por tanto, por los datos obtenidos y teniendo en cuenta que el domingo no está abierto 
ningún Mercadona (excepto ciertos casos muy concretos), deberíamos cerrar el jueves
ya que es el dia que menos compras se registran.


## Preguntas planteadas por nosotros. 

Tras analizar los datos obtenidos y resolver las preguntas anteriores nos hemos planteado las siguientes: 

### Pregunta 1 

¿A qué tienda (calle ...) pertenecen la mayor parte de los tickets? 

Queremos saber cual es la dirección donde se han realizado más compras. Para ello,
del dataframe cogemos las direcciones y las agrupamos por nombre. Después contamos 
el número de veces en las que aparece esa dirección. Por último, ordenamos los tickets 
de mayor a menor, asi seleccionamos la primera fila de la tabla que hemos creado, y 
vemos la dirección del Mercadona donde más compras se han relizado. 

```{r}

tickets_por_direccion <- df_tickets %>%
  group_by(direccion) %>%
  summarise(
    localidad = first(localidad),      
    num_tickets = n()
  ) %>%
  arrange(desc(num_tickets))

#Mostramos la dirección donde más se ha comprado 
direccion_top <- tickets_por_direccion %>% slice(1)


#Mostramos una tabla con todas las direcciones 
print(tickets_por_direccion) 
direccion_top

```
Para observar mejor la información obtenida, realizamos una gráfica de barras. 

```{r}

library(ggplot2)

# Creamos una nueva columna para combinar dirección y localidad (etiqueta completa)
tickets_por_direccion <- tickets_por_direccion %>%
  mutate(etiqueta = paste(direccion, "(", localidad, ")"))

# Graficamos
ggplot(tickets_por_direccion, aes(x = reorder(etiqueta, -num_tickets), y = num_tickets)) +
  geom_bar(stat = "identity", fill = "darkorange") +
  labs(
    title = "Número de tickets por dirección",
    x = "Dirección (Localidad)",
    y = "Número de tickets"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1)
  )


```

Observamos que la tienda (calle) con mayor número de tickets es C/ QUART 120 de 
valencia con 51 tickets.

### Pregunta 2

¿En qué horario (mañana o tarde) se hacen las compras más caras?

Queremos ver en que horario se hacen las compras más caras. Para ello, tenemos 
que sumar el precio de todas las compras en cada horario y calcular su media y su 
mediana. 

```{r}

#Agrupamos los tickets en mañana y tarde
df_tickets <- df_tickets %>%
  mutate(
    periodo_dia = ifelse(hour(hora) < 12, "Mañana", "Tarde")
  )

# Calculamos la media y la mediana de cada periodo.
compras_por_periodo <- df_tickets %>% filter(!is.na(periodo_dia)) %>%
  group_by(periodo_dia) %>%
  summarise(
    media_importe = mean(importe_total, na.rm = TRUE),
    mediana_importe = median(importe_total, na.rm = TRUE)
  )

#Mostramos el resultado en una tabla
kable(compras_por_periodo, caption = "Importe medio por periodo del día")

```

Para ver mejor los resultados obtenidos, creamos una tabla con la media y la mediana 
de las compras en cada franja horaria. 

```{r}

df_resumen <- df_tickets %>%
  group_by(franja_horaria) %>%
  summarise(media_importe = mean(importe))

ggplot(df_resumen, aes(x = franja_horaria, y = media_importe, fill = franja_horaria)) +
  geom_bar(stat = "identity", width = 0.6) +
  labs(
    title = "Importe medio de compra por franja horaria",
    x = "Franja horaria",
    y = "Importe medio (€)"
  ) +
  scale_fill_manual(values = c("mañana" = "skyblue", "tarde" = "orange")) +
  theme_minimal()


```

El resultado muestra que, en promedio, las compras realizadas por la mañana son más caras (51.69€) que las realizadas por la tarde (45.64 €). La mediana también es ligeramente más alta por la mañana (36.69 € vs. 37.38 € por la tarde), aunque la diferencia en medianas es mínima.

### Pregunta 3 

¿Cuál ha sido el ticket más caro registrado? ¿Y el más barato?

Queremos ver cual ha sido el ticket más caro y cual el más barato, para ello, tan solo 
tenemos que ordenar el dataframe, primero de mayor a menor y depués de menor a mayor, 
y quedaros con la primera fila 

```{r}

#Ordenamos de mayor a menor
ticket_mas_caro<- df_tickets %>% arrange(desc(importe_total)) %>% head(1)

#Ordenamos de menor a mayor 
ticket_mas_barato<- df_tickets %>% arrange(importe_total) %>% head(1)

cat("El ticket más caro es", ticket_mas_caro$archivo, "con un importe de: ", ticket_mas_caro$importe_total, "€", "\n")

cat("El ticket más barato es", ticket_mas_barato$archivo, "con un importe de: ", ticket_mas_barato$importe_total, "€")

```
Vemos que el ticket más caro regitrado tiene un precio de 234.2€ y el más barato 
tiene un precio de 0.43€

### Pregunta 4

¿Cómo de frecuentes son las compras de emergencia (tickets de menos de 10€)?

Algo muy común son las compras de emergencia, aquellas veces donde te falta algo indispensable 
y solo vas a comprar eso, y, por tanto, no gastas demasiado dinero en esta compra. Nos hemos 
interesado por ver la cantidad de ocasiones en que esto sucede en los tickets recogidos. 

Para ver esta información, filtramos del dataframe aquellos tickets donde las compras
son inferiores a 10 euros. También miramos que porcentaje de tikets tienen esta cualidad
sobre la canitdad de tickets total.

```{r}
compras_emergencia<- df_tickets %>% summarise(n_emergencia = sum(importe_total < 10, na.rm = TRUE),
porcentaje = mean(importe_total < 10, na.rm = TRUE) *100)


cat("Número de compras de emergencia:", compras_emergencia$n_emergencia, "\n")

cat("Porcentaje sobre el total:", compras_emergencia$porcentaje, "%", "\n")


```
Vemos que tan solo 31 tickets son de emergencia y representan un 10,9% del total. 
Por tanto, podemos decir que entre nuestros tickets no se encuentran demasiados
de compras de emergencia. 

### Pregunta 5

¿Qué localidad es la que acumula la mayor cantidad de dinero gastado en Mercadona,
y a cuánto asciende esta cifra?

Queremos saber en que localidad se gasta más dinero en el supermercado Mercadona. Para ello,
agrupamos los tickets por localidad y sumamos la cantidad de dinero gastados en ellos. 

```{r}

# Filtrar las 10 localidades con mayor gasto
top_10_localidades <- df_tickets %>%
  group_by(localidad) %>%
  summarise(total_gastado = sum(importe_total, na.rm = TRUE)) %>%
  arrange(desc(total_gastado)) %>%
  slice_head(n = 10)

# Identificar la localidad con mayor gasto
mayor_localidad <- top_10_localidades %>%
  slice_max(total_gastado)

```

Para ver mejor la información obtenida, creamos un grafico de barras. 

```{r}

# Crear el gráfico
ggplot(top_10_localidades, aes(x = reorder(localidad, total_gastado), y = total_gastado, fill = localidad)) +
  geom_bar(stat = "identity") +
  # Mostrar los valores encima de todas las barras
  geom_text(aes(label = paste0(round(total_gastado, 2), " €")),
            vjust = -0.5, size = 2.7) +
  labs(title = "Top 10 localidades con mayor gasto en Mercadona",
       x = "Localidad",
       y = "Total gastado (€)") +
  scale_fill_brewer(palette = "Paired") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```
Obtenemos claramente en la gráfica que la localidad en la que mayor cantidad de 
dinero se ha gastado en el Mercadona es Valencia con una cantidad total de 5253,03€, 
superior al doble de la segunda localidad. 

### Pregunta 6

¿Cuántos tickets se emiten entre las 9:00 y las 10:30 am comparado con el tramo de 
las 19:00-21:30?

Queremos comparar cuanta gente realiza su compra justo cuando abre el supermercado contra
cuanta gente lo hace justo antes del cierre de este. Para ello, filtramos y agrupamos 
los tickets de las compras que se han realizado en estos periodos y hacemos un recuento 
de ellos. 

```{r}

# Extraer hora y minuto desde la columna tipo Period
df_tickets <- df_tickets %>%
  mutate(
    hora_num = hour(hora) + minute(hora)/60  # convierte a decimal para comparar fácilmente
  )

# Filtrar por tramos horarios y contar los tickets en cada tramo
tickets_por_tramo <- tibble(
  tramo_horario = c("9:00 - 10:30", "19:00 - 21:30"),
  cantidad_tickets = c(
    nrow(df_tickets %>% filter(hora_num >= 9, hora_num <= 10.5)),
    nrow(df_tickets %>% filter(hora_num >= 19, hora_num <= 21.5))
  )
)

# Mostrar los resultados
print(tickets_por_tramo)

```

Para ver mejor la información obtenida realizamos un grafico de barras.

```{r}

# Crear el gráfico comparativo
ggplot(tickets_por_tramo, aes(x = tramo_horario, y = cantidad_tickets, fill = tramo_horario)) +
  geom_bar(stat = "identity") +
  labs(title = "Comparación de tickets emitidos en tramos horarios",
       x = "Tramo horario",
       y = "Cantidad de tickets") +
  scale_fill_manual(values = c("skyblue", "salmon")) +  #
  theme_minimal()  


```
Si comparamos los tickets que se emiten entre las 9:00-10:00 y entre las 19:00-21:30 
podemos ver que se emiten muchos más tickets entre 19:00-21:30, emitiéndose un poco
más de 10 veces lo que se emite por la mañana. Esto se puede deber a que la mayoria
de personas que han subido sus tickets solo pueden hacer sus compras por la tarde ya que
estudian o trabajan. 

### Pregunta 7

¿Qué producto aparece más veces en tickets de más de 100 €?

Queremos observar cual es el producto que más se compra en las compras grandes 
(superiores a 100 euros). Para ello, filtramos los tickets, agrupamos los productos 
y hacemos un recuento. 

```{r}

# Código corregido para obtener el top 5 de productos
top5_productos <- todos_los_tickets %>%
    # Filtramos solo tickets con importe_total > 100
    purrr::keep(~ .x$importe_total > 100) %>%
    # Extraemos las tablas de productos
    purrr::map_df(~ .x$productos) %>%
    # Agrupamos por descripción del producto y contamos
    group_by(descripcion) %>%
    summarise(total = sum(cantidad, na.rm = TRUE), .groups = "drop") %>%
    arrange(desc(total)) %>%
    slice_head(n = 5)  # Tomamos los 5 productos más comprados

# Mostrar el top 5
print(top5_productos)

```

Para ver mejor la información obtenida creamos un gráfico de barras.

```{r}

# Crear el gráfico de barras para los 5 productos más comprados
ggplot(top5_productos, aes(x = reorder(descripcion, total), y = total, fill = descripcion)) +
  geom_bar(stat = "identity") +
  labs(title = "Top 5 productos más comprados en compras mayores a 100€",
       x = "Producto",
       y = "Cantidad total") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  # Rotar las etiquetas del eje x para mejor legibilidad
  scale_fill_brewer(palette = "Set3") 

```
Vemos que el producto que más aparece en las compras superiores a 100€ es el espárrago 
verde fino, con un total de 17 compras distintas con un importe superior a 100€.

### Pregunta 8

¿Cuántas veces se ha comprado queso?

Queremos saber cual es la compra de queso entre los tickets recogidos. Para ello, buscamos
entre todos los productos todos los quesos y hacemos un recuento. 

```{r}

# Filtrar las filas que comienzan con "Queso"
productos_queso <- todos_los_productos[grepl("^Queso", todos_los_productos$descripcion, ignore.case = TRUE), ]

# Agrupar por descripción exacta y contar cuántas veces aparece cada línea
productos_queso_agrupado <- productos_queso %>%
  group_by(descripcion) %>%
  summarise(cantidad_total = sum(cantidad))

# Ordenar los resultados por la cantidad total
productos_queso_agrupado <- productos_queso_agrupado %>%
  arrange(desc(cantidad_total))

# Calcular el total de todos los quesos
total_quesos <- sum(productos_queso_agrupado$cantidad_total)

# Mostrar el total de quesos
print(paste("Total de quesos: ", total_quesos))

```
Vemos en una tabla la distribución de la cantidad de los diferentes quesos comprados.

```{r}

# Crear el gráfico
ggplot(productos_queso_agrupado, aes(x = reorder(descripcion, cantidad_total), y = cantidad_total)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  labs(title = "Cantidad total de quesos por tipo y marca",
       x = "Descripción del queso",
       y = "Cantidad total") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))  # Rotar las etiquetas del eje x


```
Podemos ver que el total de quesos comprados en estos ticket es de 227. Y que el queso 
más comprado es el QUESO LOCHAS CABRA.

### Pregunta 9

¿Cuál es la mayor cantidad pagada de impuestos y en qué localización se ha producido?

Queremos ver cual es la mayor canitdad de impuestos pagada. Realmente, sabemos que este
dato se encontrará entre las compras grandes pero no tiene porque ser la mayor, ya que 
los porductos tienen impuestos diferentes. 

Para calcular este dato, vamos comprando todos los impuestos pagados de todos los tickets. 

```{r}

# Obtenemos el índice de la fila con mayor IVA
indice_max_iva <- which.max(df_tickets$IVA)

# Verificamos que el índice es válido
if (!is.na(indice_max_iva) && indice_max_iva > 0) {
  fila_max_iva <- df_tickets[indice_max_iva, ]
  
  # Extraemos el IVA y la localidad
  mayor_iva <- fila_max_iva$IVA
  localizacion_max_iva <- fila_max_iva$localidad
  
  # Mostramos el resultado
  cat("La mayor cantidad pagada de impuestos es:", mayor_iva,
      "y se ha producido en:", localizacion_max_iva, "\n")
} else {
  cat("No se pudo determinar la mayor cantidad pagada de impuestos.\n")
}

```

Vemos la cantidad de impuestos pagada en cada una de las localidades en una gráfica.

```{r}

# Vamos a representarlo en un gráfico
# Agrupamos por localidad y sumamos el IVA total pagado
iva_por_localidad <- df_tickets %>%
  group_by(localidad) %>%
  summarise(total_IVA = sum(IVA, na.rm = TRUE)) %>%
  arrange(desc(total_IVA))

# Creamos el gráfico de barras
ggplot(iva_por_localidad, aes(x = localidad, y = total_IVA, fill = localidad)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Cantidad total de IVA pagado por localidad", x = "Localidad", y = "Total IVA (€)") +
  theme_minimal() +
  theme(legend.position = "none") +
  scale_fill_viridis_d()  

```
Vemos que el la ciudad de Valencia es donde más impuestos se ha pagado. Tiene sentido ya que es
donde más compras se han realizado. 
 
### Pregunta 10

¿Cuál es el producto más caro?

Queremos ver cual es el producto más caro comprado registrado en nuestros tickets. 
Para ello, agrupamos los productos iguales y después comparamos sus precios.

```{r}

# Unimos todos los productos de los tickets en un solo dataframe
df_productos <- do.call(rbind, lapply(todos_los_tickets, function(ticket) {
  ticket$productos
}))

# Filtramos el producto con el mayor importe
producto_mas_caro <- df_productos %>% arrange(desc(importe)) %>% head(1)

# Mostramos el resultado
cat("El producto más caro es:", producto_mas_caro$descripcion, 
    "con un importe de:", producto_mas_caro$importe, "€\n")

```

Mostramos en una tabla los productos más caros. 

```{r}

# Vamos a representarlo en un gráfico
# Seleccionamos los 4 productos más caros
top_productos <- df_productos %>% arrange(desc(importe)) %>% head(4)

# Creamos el gráfico de barras
ggplot(top_productos, aes(x = reorder(descripcion, importe), y = importe, fill = descripcion)) +
  geom_bar(stat = "identity") +
  coord_flip() +  
  labs(title = "Top 4 productos más caros", x = "Producto", y = "Importe (€)") +
  theme_minimal() +
  theme(legend.position = "none") +
  scale_fill_brewer(palette = "Set3")

```
Vemos que el producto más caro es el MEDIANO.
 
#Resumen

Tras la creación de la función, la lectura de los tickets de compra del Mercadona en formato PDF y el análisis de
los datos obtenidos podemos decir que el día de la semana en que más se compra es el sábado y el que menos el jueves (contando que el domingo está cerrado), que el producto más comprado en unidades es el atun en lata y la fruta más comprada el plátano y que la localidad donde más se ha comprado es en Valencia.
 
